var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PolarizedTypes","category":"page"},{"location":"#PolarizedTypes","page":"Home","title":"PolarizedTypes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PolarizedTypes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PolarizedTypes]","category":"page"},{"location":"#PolarizedTypes.CirBasis","page":"Home","title":"PolarizedTypes.CirBasis","text":"CirBasis <: PolBasis\n\nMeasurement uses the circular polarization basis, which is typically used for circular feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.CoherencyMatrix","page":"Home","title":"PolarizedTypes.CoherencyMatrix","text":"struct CoherencyMatrix{B1, B2, T} <: StaticArraysCore.FieldMatrix{2, 2, T}\n\nCoherency matrix for a single baseline with bases B1 and B2. The two bases correspond to the type of feeds used for each telescope and should be subtypes of PolBasis. To see which bases are implemented type subtypes(Rimes.PolBasis) in the REPL.\n\nFor a circular basis the layout of the coherency matrix is\n\nRR* RL*\nLR* RR*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(RR, LR, RL, LL, CirBasis())\n\nFor a linear basis the layout of the coherency matrix is\n\nXX* XY*\nYX* YY*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(XX, YX, XY, YY, CirBasis())\n\nFor a mixed (e.g., circular and linear basis) the layout of the coherency matrix is\n\nRX* RY*\nLX* LY*\n\nor e.g., linear and circular the layout of the coherency matrix is\n\nXR* XL*\nYR* YL*\n\nThese coherency matrices can be constructed using:\n\n# Circular and linear feeds i.e., |R><X|\nc = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())\n# Linear and circular feeds i.e., |X><R|\nc = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.CoherencyMatrix-2","page":"Home","title":"PolarizedTypes.CoherencyMatrix","text":"CoherencyMatrix(s::StokesParams, basis1::PolBasis)\nCoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis)\nCoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis, refbasis=CirBasis())\n\nConstructs the coherency matrix from the set of stokes parameters s. This is specialized on basis1 and basis2 which form the tensor product basis |basis1><basis2|, or if a single basis is given then by |basis><basis|.\n\nFor example\n\nCoherencyMatrix(s, CircBasis())\n\nwill give the coherency matrix\n\n   I+V   Q+iU\n   Q-iU  I-V\n\nwhile\n\nCoherencyMatrix(s, LinBasis())\n\nwill give\n\n    I+Q   U+iV\n    U-iV  I-Q\n\nNotes\n\nInternally this function first converts to a reference basis and then the final basis. You can select the reference basis used with the optional argument refbasis. By default we use the circular basis as our reference. Note that this is only important for mixed bases, e.g., if basis1 and basis2 are different. If basis1==basis2 then the reference basis is never used.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}","page":"Home","title":"PolarizedTypes.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis1::PolBasis basis2::PolBasis)\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, basis given by |basis1><basis2|.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())\n\nelements correspond to     RX* RY*     LX* LY*\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}","page":"Home","title":"PolarizedTypes.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis::PolBasis)\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, basis given by |basis><basis|.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis())\n\nelements correspond to     RR* RL*     LR* LL*\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}","page":"Home","title":"PolarizedTypes.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis::NTuple{2, PolBasis})\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, |basis[1]><basis[2]|. Note that basis[1] and basis[2] could be different.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())\n\nelements correspond to     RX* RY*     LX* LY*\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.ElectricFieldBasis","page":"Home","title":"PolarizedTypes.ElectricFieldBasis","text":"abstract type ElectricFieldBasis\n\nAn abstract type whose subtypes denote a specific electric field basis.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.LPol","page":"Home","title":"PolarizedTypes.LPol","text":"struct LPol <: PolarizedTypes.ElectricFieldBasis\n\nThe left circular electric field basis, i.e. a left-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.LinBasis","page":"Home","title":"PolarizedTypes.LinBasis","text":"LinBasis <: PolBasis\n\nMeasurement uses the linear polarization basis, which is typically used for linear feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.PolBasis","page":"Home","title":"PolarizedTypes.PolBasis","text":"struct PolBasis{B1<:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2<:Union{Missing, PolarizedTypes.ElectricFieldBasis}}\n\nDenotes a general polarization basis, with basis vectors (B1,B2) which are typically <: Union{ElectricFieldBasis, Missing}\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.RPol","page":"Home","title":"PolarizedTypes.RPol","text":"struct RPol <: PolarizedTypes.ElectricFieldBasis\n\nThe right circular electric field basis, i.e. a right-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.StokesParams","page":"Home","title":"PolarizedTypes.StokesParams","text":"struct StokesParams{T} <: StaticArraysCore.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesParams and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.XPol","page":"Home","title":"PolarizedTypes.XPol","text":"struct XPol <: PolarizedTypes.ElectricFieldBasis\n\nThe horizontal or X electric feed basis, i.e. the horizontal linear feed.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.YPol","page":"Home","title":"PolarizedTypes.YPol","text":"struct YPol <: PolarizedTypes.ElectricFieldBasis\n\nThe vertical or Y electric feed basis, i.e. the vertical linear feed.\n\n\n\n\n\n","category":"type"},{"location":"#PolarizedTypes.basis_components","page":"Home","title":"PolarizedTypes.basis_components","text":"basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)\n\nReturns a static vector that contains the components of the electric field basis vector e in terms of the polarization basis b. The first argument is optionally the eltype of the static vector.\n\nExamples\n\njulia> basis_components(Float64, R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\njulia> basis_components(R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\n\njulia> basis_components(Float64, X(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 1.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"#PolarizedTypes.basis_transform","page":"Home","title":"PolarizedTypes.basis_transform","text":"basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)\nbasis_transform([T=Float64,], b1::PolBasis=>b2::PolBasis)\n\nProduces the transformation matrix that transforms the vector components from basis b1 to basis b2. This means that if for example E is the circular basis then basis_transform(CirBasis=>LinBasis)E is in the linear basis. In other words the columns of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.\n\nExample\n\njulia> basis_transform(CirBasis()=>LinBasis())\n2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):\n 0.707107-0.0im       0.707107-0.0im\n      0.0-0.707107im       0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"#PolarizedTypes.evpa-Tuple{StokesParams}","page":"Home","title":"PolarizedTypes.evpa","text":"evpa(m::Union{StokesParams, CoherencyMatrix})\n\nCompute the evpa of a stokes vect or cohereny matrix.\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.fracpolarization-Union{Tuple{StokesParams{T}}, Tuple{T}} where T","page":"Home","title":"PolarizedTypes.fracpolarization","text":"fracpolarization(s)\n\n\nReturns the (Q/I, U/I, V/I) fractional polarization vector as a 3-element static vector.\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.innerprod","page":"Home","title":"PolarizedTypes.innerprod","text":"innerprod(::Type{T}, XPol(), YPol())\n\nComputes the complex inner product of two elements of a complex Hilbert space X and Y where base element of the output is T.\n\n\n\n\n\n","category":"function"},{"location":"#PolarizedTypes.linearpol-Tuple{StokesParams}","page":"Home","title":"PolarizedTypes.linearpol","text":"linearpol(s)\n\n\nComputes linearpol from a set of stokes parameters s.\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.mbreve-Tuple{StokesParams}","page":"Home","title":"PolarizedTypes.mbreve","text":"mbreve(m)\n\n\nComputes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used m̆\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.mpol-Union{Tuple{StokesParams{T}}, Tuple{T}} where T<:Real","page":"Home","title":"PolarizedTypes.mpol","text":"mpol(m::StokesParameters{<:Real})\n\nCompute the complex fractional linear polarization of a Stokes Parameter m\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.m̆-Union{Tuple{StokesParams{Complex{T}}}, Tuple{T}} where T","page":"Home","title":"PolarizedTypes.m̆","text":"m̆(m::Union{StokesParameters{<:Complex}, CoherencyMatrix)\n\nComputes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used mbreve\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.polarization-Tuple{StokesParams}","page":"Home","title":"PolarizedTypes.polarization","text":"polarization(s)\n\n\nReturns the (Q, U, V) polarization vector as a 3-element static vector.\n\n\n\n\n\n","category":"method"},{"location":"#PolarizedTypes.polellipse-Tuple{StokesParams{<:Real}}","page":"Home","title":"PolarizedTypes.polellipse","text":"polellipse(s)\n\n\nReturns the polarization ellipse of the Stokes parameters s. The results is a named tuple with elements\n\na   : The semi-major axis of the polarization ellipse\nb   : The semi-minor axis of the polarization ellipse\nevpa: The electric vector position angle of s or the PA of the ellipse.\nsn  : The sign of the Stokes V.\n\nNotes\n\nThe semi-major and semi-minor axes are defined as\n\n    a = 1/2(Iₚ + |L|)\n    b = 1/2(Iₚ - |L|)\n\nwhere Iₚ = √(Q² + U² + V²) and |L| = √(Q² + U²).\n\nIn general the area of the ellipse is given by\n\n    πab = π/4|V|²\n\nFor sources with zero linear polarization a = b so we have a circle with radius |V|. For purely linear polarization b = 0 giving a line with length |L|.\n\n\n\n\n\n","category":"method"}]
}
