<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PolarizedTypes.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PolarizedTypes.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PolarizedTypes"><a class="docs-heading-anchor" href="#PolarizedTypes">PolarizedTypes</a><a id="PolarizedTypes-1"></a><a class="docs-heading-anchor-permalink" href="#PolarizedTypes" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ptiede/PolarizedTypes.jl">PolarizedTypes</a>.</p><ul><li><a href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a></li><li><a href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a></li><li><a href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a></li><li><a href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a></li><li><a href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a></li><li><a href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a></li><li><a href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a></li><li><a href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a></li><li><a href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a></li><li><a href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a></li><li><a href="#PolarizedTypes.evpa-Tuple{StokesParams}"><code>PolarizedTypes.evpa</code></a></li><li><a href="#PolarizedTypes.fracpolarization-Union{Tuple{StokesParams{T}}, Tuple{T}} where T"><code>PolarizedTypes.fracpolarization</code></a></li><li><a href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a></li><li><a href="#PolarizedTypes.linearpol-Tuple{StokesParams}"><code>PolarizedTypes.linearpol</code></a></li><li><a href="#PolarizedTypes.mbreve-Tuple{StokesParams}"><code>PolarizedTypes.mbreve</code></a></li><li><a href="#PolarizedTypes.mpol-Union{Tuple{StokesParams{T}}, Tuple{T}} where T&lt;:Real"><code>PolarizedTypes.mpol</code></a></li><li><a href="#PolarizedTypes.m̆-Union{Tuple{StokesParams{Complex{T}}}, Tuple{T}} where T"><code>PolarizedTypes.m̆</code></a></li><li><a href="#PolarizedTypes.polarization-Tuple{StokesParams}"><code>PolarizedTypes.polarization</code></a></li><li><a href="#PolarizedTypes.polellipse-Tuple{StokesParams{&lt;:Real}}"><code>PolarizedTypes.polellipse</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CirBasis" href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CirBasis &lt;: PolBasis</code></pre><p>Measurement uses the circular polarization basis, which is typically used for circular feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix" href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(s::StokesParams, basis1::PolBasis)
CoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis)
CoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis, refbasis=CirBasis())</code></pre><p>Constructs the coherency matrix from the set of stokes parameters <code>s</code>. This is specialized on <code>basis1</code> and <code>basis2</code> which form the tensor product basis <code>|basis1&gt;&lt;basis2|</code>, or if a single basis is given then by <code>|basis&gt;&lt;basis|</code>.</p><p>For example</p><pre><code class="language-julia hljs">CoherencyMatrix(s, CircBasis())</code></pre><p>will give the coherency matrix</p><pre><code class="nohighlight hljs">   I+V   Q+iU
   Q-iU  I-V</code></pre><p>while</p><pre><code class="language-julia hljs">CoherencyMatrix(s, LinBasis())</code></pre><p>will give</p><pre><code class="nohighlight hljs">    I+Q   U+iV
    U-iV  I-Q</code></pre><p><strong>Notes</strong></p><p>Internally this function first converts to a reference basis and then the final basis. You can select the reference basis used with the optional argument refbasis. By default we use the circular basis as our reference. Note that this is only important for mixed bases, e.g., if <code>basis1</code> and <code>basis2</code> are different. If <code>basis1==basis2</code> then the reference basis is never used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L228-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix" href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CoherencyMatrix{B1, B2, T} &lt;: StaticArraysCore.FieldMatrix{2, 2, T}</code></pre><p>Coherency matrix for a single baseline with bases <code>B1</code> and <code>B2</code>. The two bases correspond to the type of feeds used for each telescope and should be subtypes of <code>PolBasis</code>. To see which bases are implemented type <code>subtypes(Rimes.PolBasis)</code> in the REPL.</p><p>For a circular basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RR* RL*
LR* RR*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(RR, LR, RL, LL, CirBasis())</code></pre><p>For a linear basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XX* XY*
YX* YY*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(XX, YX, XY, YY, CirBasis())</code></pre><p>For a mixed (e.g., circular and linear basis) the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RX* RY*
LX* LY*</code></pre><p>or e.g., linear and circular the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XR* XL*
YR* YL*</code></pre><p>These coherency matrices can be constructed using:</p><pre><code class="language-julia-repl hljs"># Circular and linear feeds i.e., |R&gt;&lt;X|
c = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())
# Linear and circular feeds i.e., |X&gt;&lt;R|
c = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L96-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}" href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis1::PolBasis basis2::PolBasis)</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>basis</code> given by <code>|basis1&gt;&lt;basis2|</code>.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())</code></pre><p>elements correspond to     RX* RY*     LX* LY*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L197-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}" href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis::PolBasis)</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>basis</code> given by <code>|basis&gt;&lt;basis|</code>.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis())</code></pre><p>elements correspond to     RR* RL*     LR* LL*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L176-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}" href="#PolarizedTypes.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis::NTuple{2, PolBasis})</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>|basis[1]&gt;&lt;basis[2]|</code>. Note that basis[1] and basis[2] could be different.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())</code></pre><p>elements correspond to     RX* RY*     LX* LY*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L154-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.ElectricFieldBasis" href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ElectricFieldBasis</code></pre><p>An abstract type whose subtypes denote a specific electric field basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.LPol" href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The left circular electric field basis, i.e. a left-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.LinBasis" href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinBasis &lt;: PolBasis</code></pre><p>Measurement uses the linear polarization basis, which is typically used for linear feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.PolBasis" href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolBasis{B1&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}}</code></pre><p>Denotes a general polarization basis, with basis vectors (B1,B2) which are typically <code>&lt;: Union{ElectricFieldBasis, Missing}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.RPol" href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The right circular electric field basis, i.e. a right-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.StokesParams" href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StokesParams{T} &lt;: StaticArraysCore.FieldVector{4, T}</code></pre><p>Static vector that holds the stokes parameters of a polarized complex visibility</p><p>To convert between a <code>StokesParams</code> and <code>CoherencyMatrix</code> use the <code>convert</code> function</p><pre><code class="language-julia hljs">convert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.XPol" href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct XPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The horizontal or X electric feed basis, i.e. the horizontal linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.YPol" href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct YPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The vertical or Y electric feed basis, i.e. the vertical linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/types.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.basis_components" href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)</code></pre><p>Returns a static vector that contains the components of the electric field basis vector <code>e</code> in terms of the polarization basis <code>b</code>. The first argument is optionally the eltype of the static vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; basis_components(Float64, R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im

julia&gt; basis_components(R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im


julia&gt; basis_components(Float64, X(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 1.0 + 0.0im
 0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/basis_transforms.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.basis_transform" href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)
basis_transform([T=Float64,], b1::PolBasis=&gt;b2::PolBasis)</code></pre><p>Produces the transformation matrix that transforms the vector components from basis <code>b1</code> to basis <code>b2</code>. This means that if for example <code>E</code> is the circular basis then <code>basis_transform(CirBasis=&gt;LinBasis)E</code> is in the linear basis. In other words the <strong>columns</strong> of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis_transform(CirBasis()=&gt;LinBasis())
2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.707107-0.0im       0.707107-0.0im
      0.0-0.707107im       0.0+0.707107im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/basis_transforms.jl#L75-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.evpa-Tuple{StokesParams}" href="#PolarizedTypes.evpa-Tuple{StokesParams}"><code>PolarizedTypes.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(m::Union{StokesParams, CoherencyMatrix})</code></pre><p>Compute the evpa of a stokes vect or cohereny matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L94-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.fracpolarization-Union{Tuple{StokesParams{T}}, Tuple{T}} where T" href="#PolarizedTypes.fracpolarization-Union{Tuple{StokesParams{T}}, Tuple{T}} where T"><code>PolarizedTypes.fracpolarization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fracpolarization(s)
</code></pre><p>Returns the (Q/I, U/I, V/I) fractional polarization vector as a 3-element static vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.innerprod" href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerprod(::Type{T}, XPol(), YPol())</code></pre><p>Computes the complex inner product of two elements of a complex Hilbert space <code>X</code> and <code>Y</code> where base element of the output is T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/basis_transforms.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.linearpol-Tuple{StokesParams}" href="#PolarizedTypes.linearpol-Tuple{StokesParams}"><code>PolarizedTypes.linearpol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearpol(s)
</code></pre><p>Computes <code>linearpol</code> from a set of stokes parameters <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.mbreve-Tuple{StokesParams}" href="#PolarizedTypes.mbreve-Tuple{StokesParams}"><code>PolarizedTypes.mbreve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mbreve(m)
</code></pre><p>Computes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used <a href="#PolarizedTypes.m̆-Union{Tuple{StokesParams{Complex{T}}}, Tuple{T}} where T"><code>m̆</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.mpol-Union{Tuple{StokesParams{T}}, Tuple{T}} where T&lt;:Real" href="#PolarizedTypes.mpol-Union{Tuple{StokesParams{T}}, Tuple{T}} where T&lt;:Real"><code>PolarizedTypes.mpol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpol(m::StokesParameters{&lt;:Real})</code></pre><p>Compute the complex fractional linear polarization of a Stokes Parameter <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.m̆-Union{Tuple{StokesParams{Complex{T}}}, Tuple{T}} where T" href="#PolarizedTypes.m̆-Union{Tuple{StokesParams{Complex{T}}}, Tuple{T}} where T"><code>PolarizedTypes.m̆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m̆(m::Union{StokesParameters{&lt;:Complex}, CoherencyMatrix)</code></pre><p>Computes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used <a href="#PolarizedTypes.mbreve-Tuple{StokesParams}"><code>mbreve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.polarization-Tuple{StokesParams}" href="#PolarizedTypes.polarization-Tuple{StokesParams}"><code>PolarizedTypes.polarization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarization(s)
</code></pre><p>Returns the (Q, U, V) polarization vector as a 3-element static vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.polellipse-Tuple{StokesParams{&lt;:Real}}" href="#PolarizedTypes.polellipse-Tuple{StokesParams{&lt;:Real}}"><code>PolarizedTypes.polellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polellipse(s)
</code></pre><p>Returns the polarization ellipse of the Stokes parameters <code>s</code>. The results is a named tuple with elements</p><ul><li><code>a</code>   : The semi-major axis of the polarization ellipse</li><li><code>b</code>   : The semi-minor axis of the polarization ellipse</li><li><code>evpa</code>: The electric vector position angle of <code>s</code> or the PA of the ellipse.</li><li><code>sn</code>  : The sign of the Stokes <code>V</code>.</li></ul><p><strong>Notes</strong></p><p>The semi-major and semi-minor axes are defined as</p><pre><code class="nohighlight hljs">    a = 1/2(Iₚ + |L|)
    b = 1/2(Iₚ - |L|)</code></pre><p>where <code>Iₚ = √(Q² + U² + V²)</code> and <code>|L| = √(Q² + U²)</code>.</p><p>In general the area of the ellipse is given by</p><pre><code class="nohighlight hljs">    πab = π/4|V|²</code></pre><p>For sources with zero linear polarization <code>a = b</code> so we have a circle with radius <code>|V|</code>. For purely linear polarization <code>b = 0</code> giving a line with length <code>|L|</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/1dab39692cf70ace76febd16216f5788d3ef1093/src/functions.jl#L19-L48">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 23 August 2023 15:57">Wednesday 23 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
